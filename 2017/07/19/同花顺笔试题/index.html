<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>同花顺笔试题 | 蜗居</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">同花顺笔试题</h1><a id="logo" href="/.">蜗居</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">同花顺笔试题</h1><div class="post-meta">Jul 19, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>今天做了同花顺的笔试题，感觉还是对基础考验挺大的，来自己总结一下，因为做的时候不能百度，所以线下再来做一遍。深入了解一下。（写的不对的地方可拍砖）</p>
<a id="more"></a>
<h2 id="第一题：A函数与B函数都实现相同的功能，那么如何去检测这两个函数的执行效率呢？写出你的思路并用代码实现。"><a href="#第一题：A函数与B函数都实现相同的功能，那么如何去检测这两个函数的执行效率呢？写出你的思路并用代码实现。" class="headerlink" title="第一题：A函数与B函数都实现相同的功能，那么如何去检测这两个函数的执行效率呢？写出你的思路并用代码实现。"></a>第一题：A函数与B函数都实现相同的功能，那么如何去检测这两个函数的执行效率呢？写出你的思路并用代码实现。</h2><p><strong>思路：</strong>看到这道题的直观感觉就是效率和时间等同。那问题就等同于检测函数的运行时间。<br>答题的时候，我就举了一个循环相加的例子。然后测他的时间。<br>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function add() &#123;</div><div class="line">    let sum = 0;</div><div class="line">    for(let i = 0; i &lt; 100000; i++)&#123;</div><div class="line">        sum += i;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div><div class="line">function test(func) &#123;</div><div class="line">    let start = new Date().getTime();</div><div class="line">    func();</div><div class="line">    let end = new Date().getTime();</div><div class="line">    return `$&#123;end - start&#125;ms`</div><div class="line">&#125;</div><div class="line">console.log(test(add));</div></pre></td></tr></table></figure></p>
<h2 id="第二题：列举两种及以上JSON字符串转化为JSON对象"><a href="#第二题：列举两种及以上JSON字符串转化为JSON对象" class="headerlink" title="第二题：列举两种及以上JSON字符串转化为JSON对象"></a>第二题：列举两种及以上JSON字符串转化为JSON对象</h2><p>这题当时就写出两种，一种是浏览器的方法，还有一种是JS的方法<br>以下方法都以此举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string1 = &apos;&#123;&quot;name&quot;: &apos;laihuamin&apos;&#125;&apos;</div><div class="line">转换后的对象</div><div class="line">var string2 = &#123;&quot;name&quot;: &apos;laihuamin&apos;&#125;</div></pre></td></tr></table></figure></p>
<p>第一种：JSON.parse()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string2 = JSON.parse(string1);</div></pre></td></tr></table></figure></p>
<p>第二种：eval()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">string2 = eval(&apos;(&apos;+ string1 +&apos;)&apos;);</div></pre></td></tr></table></figure></p>
<p>以下是从网上查来的，就当科普：<br>第三种： new Function形式(待定)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function strJSON(str) &#123;</div><div class="line">    var json = (new Function(&quot;return&quot; + str))();</div><div class="line">    return json;</div><div class="line">&#125;</div><div class="line">var string2 = strJSON(string1);</div></pre></td></tr></table></figure></p>
<p>第四种：json2.js进行转换<br>json2.js提供序列化和反序列话的方法，完美支持各种浏览器。源码地址：<a href="https://github.com/douglascrockford/JSON-js" target="_blank" rel="external">https://github.com/douglascrockford/JSON-js</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var string2 = JSON.parse(string2);</div></pre></td></tr></table></figure></p>
<p>有人可能会问，这不是和第一种方法一样么，但是第一种方法字符串必须严格按照JSON的规范，不然会报错。<br>第五种：jQuery提供的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var string2 = $.parseJSON(string1);</div></pre></td></tr></table></figure></p>
<h2 id="第三题：描述客户端从页面发出请求到展示页面发生了些什么？"><a href="#第三题：描述客户端从页面发出请求到展示页面发生了些什么？" class="headerlink" title="第三题：描述客户端从页面发出请求到展示页面发生了些什么？"></a>第三题：描述客户端从页面发出请求到展示页面发生了些什么？</h2><p>首先，我觉得出这一题是为了考察http请求的整个响应过程，个人感觉自己懂，但是答题的时候却说不出规范点的词汇。步骤如下：<br><strong>1、输入地址<br>2、浏览器解析域名，得到ip地址。（其实域名只是方便记忆用的，这一点很清楚的在图解http中说明，人脑对一串数字没有对一串语义化的域名来的敏感，所以出现了域名和DNS解析。。。博主没有记错的话，书里是这么讲的0.0）<br>3、浏览器向web发送http请求（如果不懂的同学可以看这篇<a href="https://cnbin.github.io/blog/2016/02/20/http-qing-qiu-,-xiang-ying-,-huan-cun/" target="_blank" rel="external">博文</a>,想深入了解的不如可以像博主一样，现在疯狂啃书0.0——图解http这本书很不错）。<br>4、服务器发送永久的重定向响应（原因等到下面再讲）<br>5、浏览器跟踪重定向地址<br>6、服务器处理请求<br>7、浏览器返回一个HTTP响应<br>8、浏览器显示HTML内容<br>9、浏览器发送请求获取HTML中的资源（如图片、音频、css、JS等）</strong></p>
<p>扩展知识范畴：<br>1、为什么需要重定向响应，其中的一个原因是跟搜索排名相关，因为当一个页面有两个地址的时候，如一个页面有www.google.com和google.com服务器会认为他是两个页面，这样会导致每个搜索链减少从而影响排名。还有一个就是一个页面多个地址会产生缓存不友好性，一个页面缓存多次，而有了重定向响应之后，搜索引擎知道301重定向响应是什么，就会把上述两个地址归为一个地址。<br>2、301和302都是重定向的状态码，那么他们的区别在哪里呢，301是表示旧地址资源已经不存在了，搜索引擎在抓取新内容的时候也就网址重定向到新的网址；302是表示旧地址上的资源还在，这个重定向就是从旧跳到新的地址，搜索引擎会在抓取新地址的同时保留旧地址。<br>3、重定向的原因：<br>⑴网页页面调整<br>⑵网页被移到新地址<br>⑶网页的扩展名改变</p>
<h2 id="第四题：如下变量var-foo-‘a’-1-为获取foo属性为a的值，foo-fn-‘a’-2-为设置foo的属性的值为2？如果要在所有对象上面添加fn函数功能，该如何实现？"><a href="#第四题：如下变量var-foo-‘a’-1-为获取foo属性为a的值，foo-fn-‘a’-2-为设置foo的属性的值为2？如果要在所有对象上面添加fn函数功能，该如何实现？" class="headerlink" title="第四题：如下变量var foo = {‘a’: 1}为获取foo属性为a的值，foo.fn(‘a’, 2)为设置foo的属性的值为2？如果要在所有对象上面添加fn函数功能，该如何实现？"></a>第四题：如下变量var foo = {‘a’: 1}为获取foo属性为a的值，foo.fn(‘a’, 2)为设置foo的属性的值为2？如果要在所有对象上面添加fn函数功能，该如何实现？</h2><p>思路：这是考ES6的解构赋值方法和如何给对象原型添加方法<br>var foo = {‘a’: 1};<br>Object.prototype.fn = function (str, y) {<br>    this[str] = y;<br>}<br>foo.fn(‘a’, 2);<br><strong>知识拓展：原型链</strong><br>首先从两个概念讲起_proto_和prototype<br>什么是_proto_ ? _proto_属性值对应的就是他们的原型对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var o = &#123;x: 1&#125;;</div><div class="line">o._proto_ === Object.prototype //true</div><div class="line">var two = new Object();</div><div class="line">two._proto_ === Object.prototype //true</div><div class="line">one.toString() //?</div><div class="line">one._proto_.toString() //?</div><div class="line">one.toString() === one._proto_.toString() //?</div></pre></td></tr></table></figure></p>
<p>如果了解了_proto_你就会懂，他输出的是什么。<br><strong>第一个 one是一个对象，那么对象的toString()会输出什么呢？ ——&gt; [object Object] </strong><br>第二个 one._proto_是什么呢？<br><strong>我们先来讲讲Object.prototype是什么：</strong><br>先来说说prototype这个属性，凭什么o和two的_proto_等于Object.prototype。<br><strong>只有函数才有prototype属性</strong>，为什么这么说。<br>因为在js中没有类这么一个概念（在ES6中已经引入类这个语法糖，不过是根据Object.create方法创建的类），所以要用函数来模拟一个类。在每个函数创建的时候，都会自动添加prototype属性。值为空对象，当你把此函数当作构造函数（constructor）调用时（用new创建实例），新的实例继承原函数的prototype的所有属性和方法。（实例通过设置自己的_proto_来指向原函数的prototype来继承）。<br><strong>接下来我们进行更深一步的探讨</strong><br>有一句话说JS是单继承，Object.prototype是原型链的顶端，所有实例都从他这里继承toString()等方法。<br>还有一种说法就是 Object本身就是一种构造函数，继承Function.prototype方法;Function也是对象，继承Object.prototype方法。<br>这里就存在一个鸡和蛋的问题？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object instanceof Function //true</div><div class="line">Function instanceof Object //true</div></pre></td></tr></table></figure></p>
<p>ES是这么说的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Function本身就是函数，Function._proto_的原型就是Function.prototype</div><div class="line">Function.prototype._proto_等于Object.prototype</div></pre></td></tr></table></figure></p>
<p>所以用一张图概括：<br><img src="https://camo.githubusercontent.com/b8806bd76878881e7f843b0e77643aff26594ecf/687474703a2f2f3773626e62612e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f6769746875622d6a732d70726f746f747970652e6a7067" alt="原型及原型链"><br>那么我们现在来解决这一个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">one.toString() // [object Object]</div><div class="line">one._proto_.toString() // [object Object]</div><div class="line">one.toString() === one._proto_.toString() // true</div></pre></td></tr></table></figure></p>
<h2 id="第五题：写一个字符串为驼峰的方法：如：border-bottom-color转变成-borderBottomColor。至少写两种"><a href="#第五题：写一个字符串为驼峰的方法：如：border-bottom-color转变成-borderBottomColor。至少写两种" class="headerlink" title="第五题：写一个字符串为驼峰的方法：如：border-bottom-color转变成 borderBottomColor。至少写两种"></a>第五题：写一个字符串为驼峰的方法：如：border-bottom-color转变成 borderBottomColor。至少写两种</h2><p>思路：这个写两种方法，<strong>第一种用字符串的split()方法将其拆成一个一个单词，然后将后面的单词用数组的join方法加起来;第二种方法用正则表达式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function change(str) &#123;</div><div class="line">    let arr = str.split(&apos;-&apos;);</div><div class="line">    for(let i = 1; i &lt; arr.length - 1; i++)&#123;</div><div class="line">        //把从第二个开始的首字母变成大写字母</div><div class="line">        arr[i] = arr[i].charAt[0].toUpperCase() + arr[i].substring(1, arr[i].length - 1)</div><div class="line">    &#125;</div><div class="line">    return arr.join(&apos;&apos;);</div><div class="line">&#125;</div><div class="line">let str2 = &apos;border-bottom-color&apos;;</div><div class="line">let str1 = change(str2);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function change(str) &#123;</div><div class="line">   let reg = /-(\w+)/g</div><div class="line">   return this.repalce(reg, function () &#123;</div><div class="line">       let args = argsment;</div><div class="line">       return args[1].toUpperCase();</div><div class="line">   &#125;)</div><div class="line">&#125;</div><div class="line">let str2 = &apos;border-bottom-color&apos;;</div><div class="line">let str1 = change(str2)</div></pre></td></tr></table></figure>
<h2 id="第六题：写出两次的输出结果并说明原因"><a href="#第六题：写出两次的输出结果并说明原因" class="headerlink" title="第六题：写出两次的输出结果并说明原因"></a>第六题：写出两次的输出结果并说明原因</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">function fn1 () &#123;</div><div class="line">   alert(a);</div><div class="line">   var a = 2;</div><div class="line"> &#125;</div><div class="line"> fn1();</div><div class="line"> alert(a); </div><div class="line"> //undefined</div><div class="line"> //1</div></pre></td></tr></table></figure>
<p>好气啊，怎么简单的一题错了，其实这题是讲变量提升的…0.0<br>先让我们来先以下这个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">function fn1 () &#123;</div><div class="line">   alert(a);</div><div class="line">   a = 2;</div><div class="line"> &#125;</div><div class="line">fn1();</div><div class="line">alert(a); </div><div class="line">//1</div><div class="line">//2</div></pre></td></tr></table></figure></p>
<p>这个例子输出的结果和上面的完全不一样，为什么呢？原因就在var上面<br>当没有var的时候，函数内的a是全局的a，当函数打印a时输出的是1，然后执行函数改变了函数的值，a就变成2了<br>而上面的例子函数内部的a是个局部变量，而这个局部变量存在变量提升问题，所以函数输出的是undefined，而全局变量根本没有改变，还是输出1。</p>
<h2 id="第七题：输出两次的结果"><a href="#第七题：输出两次的结果" class="headerlink" title="第七题：输出两次的结果"></a>第七题：输出两次的结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;btn1&quot;&gt;</div><div class="line">function a() &#123;</div><div class="line">    alert(&apos;this&apos;);</div><div class="line">&#125;</div><div class="line">例子一：</div><div class="line">var Btn = doucment.getElementById(&apos;btn1&apos;);</div><div class="line">Btn.onclick = a;</div><div class="line">例子二：</div><div class="line">var Btn = doucment.getElementById(&apos;btn1&apos;);</div><div class="line">Btn.onclick = function () &#123;</div><div class="line">    a();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个例子输出的是  <input type="button" name="" id="btn1"><br>第二个例子输出的是  [Object window]<br>接下里再让我们来看一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var Btn = document.getElementById(&apos;btn1&apos;);</div><div class="line">Btn.onclick = a();</div></pre></td></tr></table></figure></p>
<p>问题来了，和例子一惊人的像有木有，但是差一个括号，结果却天差地别。在高程第七章的时候有介绍。<br>输出的是window对象，相当于执行了一次函数，而没有添加click事件。</p>
<h2 id="第八题：有一个单张手机页面需要在某一个时间点推送出去，并发量可能会很大。如果是你来制作这个手机活动页面会考虑哪些方面？发布上线前会做什么？"><a href="#第八题：有一个单张手机页面需要在某一个时间点推送出去，并发量可能会很大。如果是你来制作这个手机活动页面会考虑哪些方面？发布上线前会做什么？" class="headerlink" title="第八题：有一个单张手机页面需要在某一个时间点推送出去，并发量可能会很大。如果是你来制作这个手机活动页面会考虑哪些方面？发布上线前会做什么？"></a>第八题：有一个单张手机页面需要在某一个时间点推送出去，并发量可能会很大。如果是你来制作这个手机活动页面会考虑哪些方面？发布上线前会做什么？</h2><h2 id="第九题：写一个模态框的实现思路，及相关代码-要求打开按钮、标题、内容、输入、关闭按钮"><a href="#第九题：写一个模态框的实现思路，及相关代码-要求打开按钮、标题、内容、输入、关闭按钮" class="headerlink" title="第九题：写一个模态框的实现思路，及相关代码(要求打开按钮、标题、内容、输入、关闭按钮)"></a>第九题：写一个模态框的实现思路，及相关代码(要求打开按钮、标题、内容、输入、关闭按钮)</h2><p><strong>HTML部分</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;wrapper&quot;&gt;</div><div class="line">    &lt;button class=&quot;open&quot;&gt;打开&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;overlay&quot;&gt;</div><div class="line">    &lt;div class=&quot;con&quot;&gt;</div><div class="line">        &lt;h1 class=&quot;con-title&quot;&gt;这是一个标题&lt;/h1&gt;</div><div class="line">        &lt;p class=&quot;con-con&quot;&gt;内容&lt;/p&gt;</div><div class="line">        &lt;input class=&quot;con-input&quot; type=&quot;text&quot; name=&quot;&quot;&gt;</div><div class="line">        &lt;button class=&quot;close&quot;&gt;&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>JS部分</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.onload = function () &#123;</div><div class="line">    var openBtn = document.getElementsByClassName(&apos;open&apos;)[0];</div><div class="line">    var closeBtn = document.getElementsByClassName(&apos;close&apos;)[0];</div><div class="line">    var con = document.getElementsByClassName(&apos;overlay&apos;)[0];</div><div class="line">    openBtn.onclick = function () &#123;</div><div class="line">        con.style.display = &apos;block&apos;;</div><div class="line">    &#125;</div><div class="line">    closeBtn.onclick = function () &#123;</div><div class="line">        con.style.display = &apos;none&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="第十题：-以下代码是否存在问题？如果有，请指出具体的问题和改进的方案。"><a href="#第十题：-以下代码是否存在问题？如果有，请指出具体的问题和改进的方案。" class="headerlink" title="第十题： 以下代码是否存在问题？如果有，请指出具体的问题和改进的方案。"></a>第十题： 以下代码是否存在问题？如果有，请指出具体的问题和改进的方案。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">     var objectA = new Object();</div><div class="line">     var objectB = new Object();</div><div class="line">     objectA.someOtherObject = objectB;</div><div class="line">     objectB.anotherObject = objectA;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是个引用计数无法垃圾回收的例子，千万不要去浏览器上跑，直接把我的浏览器卡奔溃了。<br>在这个例子中，A中有个方法指向B，B中也有个属性指向A，这样就会造成相互引用，然后造成大量内存无法回收，进入死循环。<br>这样的例子有很多，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var element = document.getElementById(&quot;element&quot;);</div><div class="line">var myObject = new Object();</div><div class="line">myObject.elemnet = element;</div><div class="line">element.someObject = myObject;</div></pre></td></tr></table></figure></p>
<p>对于这个例子来讲也是一个循环引用的例子，myObject有element方法指向element对象，element有someObject方法指向myObject方法。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://laihuamin.github.io/2017/07/19/同花顺笔试题/" data-id="cj5dbo7ra00022gqly459h1uk" class="article-share-link">Aktie</a><div class="tags"></div><div class="post-nav"><a href="/2017/07/20/web安全/" class="pre">常见的web安全问题</a><a href="/2017/07/18/前端总结/" class="next">前端总结（一）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://laihuamin.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 其他</i></div><ul></ul><a href="http://www.jianshu.com/u/5be4d0169f64" title="简书" target="_blank">简书</a><ul></ul><a href="https://github.com/laihuamin" title="github" target="_blank">github</a></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/服务器上的node安装以及项目配置/">服务器上的node安装以及项目配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/20/web安全/">常见的web安全问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/19/同花顺笔试题/">同花顺笔试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/18/前端总结/">前端总结（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/ES6——阮一峰（学习笔记）/">ES6——阮一峰（学习笔记）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 作品集</i></div><ul></ul><a href="http://www.51nannan.cn/resume/index.html" title="简历" target="_blank">简历</a><ul></ul><a href="http://119.23.222.225:8082/#/goods" title="饿了么作品" target="_blank">饿了么作品</a><ul></ul><a href="http://119.23.222.225:8083/#/recommend" title="音乐App" target="_blank">音乐App</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">蜗居.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>