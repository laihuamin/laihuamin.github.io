<!DOCTYPE html><html lang="null"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>虚拟dom | 蜗居</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">虚拟dom</h1><a id="logo" href="/.">蜗居</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">虚拟dom</h1><div class="post-meta">Aug 2, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>DOM(document object modle),在浏览器中我们直接用js来操作dom，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>vue2.0加入了virtual dom，有向react靠拢的意思。vue的diff位于patch.js文件中，复杂度O(n)</p>
<h2 id="VNode对象"><a href="#VNode对象" class="headerlink" title="VNode对象"></a>VNode对象</h2><p><strong>一个VNode对象包含以下属性：</strong><br>1、tag：当前节点的标签名<br>2、data：当前节点的对象数据，从vue的源码中可以看出data包括一下的内容：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">interface</span> VNodeData&#123;</div><div class="line">    key?:<span class="built_in">string</span> | <span class="built_in">number</span>;</div><div class="line">    solt?: <span class="built_in">string</span>;</div><div class="line">    scopeSolts?: &#123;[key: <span class="built_in">string</span>]: ScopeSolt&#125;;</div><div class="line">    ref?: <span class="built_in">string</span>;</div><div class="line">    tag?: <span class="built_in">string</span>;</div><div class="line">    staticClass?: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">class</span>?: <span class="built_in">any</span>;</div><div class="line">    staticStyle?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</div><div class="line">    style?: <span class="built_in">Object</span>[] | <span class="built_in">Object</span>;</div><div class="line">    props?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</div><div class="line">    attrs?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</div><div class="line">    domProps?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</div><div class="line">    hook?: &#123;[key:<span class="built_in">string</span>]: <span class="built_in">Function</span>&#125;;</div><div class="line">    on?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[]&#125;;</div><div class="line">    nativeOn?: &#123;[key: <span class="built_in">string</span>]: <span class="built_in">Function</span> | <span class="built_in">Function</span>[]&#125;;</div><div class="line">    transition?: <span class="built_in">Object</span>;</div><div class="line">    show?: <span class="built_in">boolean</span>;</div><div class="line">    inlineTemplate?: &#123;</div><div class="line">        render: <span class="built_in">Function</span>;</div><div class="line">        staticRenderFns: <span class="built_in">Function</span>[];</div><div class="line">    &#125;;</div><div class="line">    directives?: VNodeDirectives[];</div><div class="line">    keepAlive?: <span class="built_in">boolean</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、children：数组类型，当前节点的子节点<br>4、text：当前节点的文本内容<br>5、elm：当前虚拟dom节点对应的真实dom节点<br>6、ns: 节点的namespace<br>7、context: 编译作用域<br>8、functionalContext: 函数化组件的作用域<br>9、key: 节点的key属性，用于作为节点的标识，有利于patch的优化<br>10、componentOptions: 创建组件实例时会用到的选项信息<br>11、child: 当前节点对应的组件实例<br>12、parent: 组件的占位节点<br>13、raw: raw html<br>14、isStatic: 静态节点的标识<br>15、isRootInsert: 是否作为根节点插入，被&lt; transition&gt;包裹的节点，该属性的值为false<br>16、isComment: 当前节点是否是注释节点<br>17、isCloned: 当前节点是否为克隆节点<br>18、isOnce: 当前节点是否有v-once指令</p>
<h2 id="VNode分类"><a href="#VNode分类" class="headerlink" title="VNode分类"></a>VNode分类</h2><p><img src="https://sfault-image.b0.upaiyun.com/339/610/3396104381-5899cba0185f2_articlex" alt="VNode"><br>VNode可以理解为vue框架的虚拟dom的基类，通过new实例化的VNode大致可以分为几类:<br>1、EmptyVNode： 没有内容的注释节点<br>2、TextVNode：文本节点<br>3、ElementVNode：普通元素节点<br>4、ComponentVNode：组件节点<br>5、CloneVNode：克隆节点，与任意节点的区别就是isClone属性值为true<br>6、···</p>
<h2 id="分析diff算法"><a href="#分析diff算法" class="headerlink" title="分析diff算法"></a>分析diff算法</h2><p><strong>例子</strong><br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff.png" alt="流程图"><br>react的diff和vue的diff大同小异，只进行同级比较，不进行跨级比较。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 之前 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>           <span class="comment">&lt;!-- 层级1 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>            <span class="comment">&lt;!-- 层级2 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span> aoy <span class="tag">&lt;/<span class="name">b</span>&gt;</span>   <span class="comment">&lt;!-- 层级3 --&gt;</span>   </div><div class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>diff<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">P</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 之后 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>            <span class="comment">&lt;!-- 层级1 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>             <span class="comment">&lt;!-- 层级2 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">b</span>&gt;</span> aoy <span class="tag">&lt;/<span class="name">b</span>&gt;</span>        <span class="comment">&lt;!-- 层级3 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>diff<span class="tag">&lt;/<span class="name">Span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>最优的解法应该是把span标签移到p标签的外面去，但是算法不会这么做，他是移除了p标签的span，在外面添加一个span。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><strong>diff的过程就是调用patch的过程：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode</span>) </span>&#123;</div><div class="line">	<span class="keyword">if</span> (sameVnode(oldVnode, vnode)) &#123;</div><div class="line">		patchVnode(oldVnode, vnode)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">const</span> oEl = oldVnode.el</div><div class="line">		<span class="keyword">let</span> parentEle = api.parentNode(oEl)</div><div class="line">		createEle(vnode)</div><div class="line">		<span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</div><div class="line">			api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))</div><div class="line">			api.removeChild(parentEle, oldVnode.el)</div><div class="line">			oldVnode = <span class="literal">null</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>patch接受两个参数，第一个是oldVnode，和第二个Vnode，这么新旧的虚拟节点，vnode前面我们已经介绍过了，我们再来举个例子加深印象。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// body下的 &lt;div id="v" class="classA"&gt;&lt;div&gt; 对应的 oldVnode 就是</span></div><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="attribute">el</span>:  div  <span class="comment">//对真实的节点的引用，本例中就是document.querySelector('#id.classA')</span></div><div class="line">  <span class="attribute">tagName</span>: <span class="string">'DIV'</span>,   <span class="comment">//节点的标签</span></div><div class="line">  <span class="attribute">sel</span>: <span class="string">'div#v.classA'</span>  <span class="comment">//节点的选择器</span></div><div class="line">  <span class="attribute">data</span>: null,       <span class="comment">// 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style</span></div><div class="line">  <span class="attribute">children</span>: [], <span class="comment">//存储子节点的数组，每个子节点也是vnode结构</span></div><div class="line">  <span class="attribute">text</span>: null,    <span class="comment">//如果是文本节点，对应文本节点的textContent，否则为null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，el属性引用的是此 virtual dom对应的真实dom，patch的vnode参数的el最初是null，因为patch之前它还没有对应的真实dom。<br>接下来，看patch的第一部分<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span> <span class="params">(sameVnode(oldVnode, vnode))</span> &#123;</span></div><div class="line">		<span class="title">patchVnode</span><span class="params">(oldVnode, vnode)</span></div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>看两个vnode是否值得做比较做比较，先来看一下sameVnode函数<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="title">sameVnode</span>(oldVnode, vnode)&#123;</div><div class="line">	<span class="keyword">return</span> <span class="type">vnode.key</span> === oldVnode.key &amp;&amp; vnode.sel === oldVnode.sel</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当key和sel一样式才值得比较，比如p和span，div.classA和div.classB就不值得做比较。patchVnode延后再看<br>先看看不值得做比较的<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">		const <span class="attr">oEl</span> = oldVnode.el</div><div class="line">		<span class="keyword">let</span> <span class="attr">parentEle</span> = api.parentNode(oEl)</div><div class="line">		createEle(vnode)</div><div class="line">		<span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</div><div class="line">			api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))</div><div class="line">			api.removeChild(parentEle, oldVnode.el)</div><div class="line">			<span class="attr">oldVnode</span> = <span class="literal">null</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>过程如下:<br>1、获得oldVnode.el的父节点，parentEle是真实的dom<br>2、createEle(vnode)会给vnode创建一个真实的dom，即vnode.el = 真实的dom<br>3、parentEle将新的节点插入，将旧的节点移出<br>不值得比较时，直接用新的将旧的替换。<br>最后<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> vnode</div></pre></td></tr></table></figure></p>
<p>vnode在进入patch和返回之后有什么区别？当然，vnode.el在进入之前是null，出来之后是被引用的真实的dom。<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> oldVnode = <span class="keyword">patch</span>(oldVnode, vnode)</div></pre></td></tr></table></figure></p>
<p>这就是整个patch过程。<br><strong>当两个节点值得比较时</strong><br>会调用patchVnode()函数<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">patchVnode (oldVnode, vnode) &#123;</div><div class="line">    <span class="keyword">const</span> el = vnode.el = oldVnode.el</div><div class="line">    let i, oldCh = oldVnode.children, ch = vnode.children</div><div class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></div><div class="line">    <span class="keyword">if</span> (oldVnode.<span class="built_in">text</span> !== <span class="keyword">null</span> &amp;&amp; vnode.<span class="built_in">text</span> !== <span class="keyword">null</span> &amp;&amp; oldVnode.<span class="built_in">text</span> !== vnode.<span class="built_in">text</span>) &#123;</div><div class="line">        api.setTextContent(el, vnode.<span class="built_in">text</span>)</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        updateEle(el, vnode, oldVnode)</div><div class="line">    	<span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</div><div class="line">	    	updateChildren(el, oldCh, ch)</div><div class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch)&#123;</div><div class="line">	    	createEle(vnode) <span class="comment">//create el's children dom</span></div><div class="line">	    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldCh)&#123;</div><div class="line">	    	api.removeChildren(el)</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>const el = vnode.el = oldVnode.el 这是很重要的一步，让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化。<br>节点比较有五种情况：<br>1、if (oldVnode === vnode)，当节点是引用一致的，可以当作没有变化<br>2、if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) ，如果比较节点文本，如果说需要修改会调用setTextContent函数<br>3、if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch)两个节点都有子节点，而子节点不一样，会调用updateChildren函数更新子节点，diff的核心<br>4、if (ch)，oldVnode没有子节点，会调用createEle(vnode)，会给老的节点添加新的子节点<br>5、else if (oldCh)，如果vnode没有子节点，那么会调用removeChildren(el)，将子节点移除<br><strong>updateChildren函数</strong><br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">updateChildren (parentElm, oldCh, <span class="keyword">new</span><span class="type">Ch</span>) &#123;</div><div class="line">    let oldStartIdx = <span class="number">0</span>, <span class="keyword">new</span><span class="type">StartIdx</span> = <span class="number">0</span></div><div class="line">    let oldEndIdx = oldCh.length - <span class="number">1</span></div><div class="line">    let oldStartVnode = oldCh[<span class="number">0</span>]</div><div class="line">    let oldEndVnode = oldCh[oldEndIdx]</div><div class="line">    let <span class="keyword">new</span><span class="type">EndIdx</span> = <span class="keyword">new</span><span class="type">Ch</span>.length - <span class="number">1</span></div><div class="line">    let <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[<span class="number">0</span>]</div><div class="line">    let <span class="keyword">new</span><span class="type">EndVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[<span class="keyword">new</span><span class="type">EndIdx</span>]</div><div class="line">    let oldKeyToIdx</div><div class="line">    let idxInOld</div><div class="line">    let elmToMove</div><div class="line">    let before</div><div class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; <span class="keyword">new</span><span class="type">StartIdx</span> &lt;= <span class="keyword">new</span><span class="type">EndIdx</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;   <span class="comment">//对于vnode.key的比较，会把oldVnode = null</span></div><div class="line">                oldStartVnode = oldCh[++oldStartIdx] </div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</div><div class="line">                oldEndVnode = oldCh[--oldEndIdx]</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">StartVnode</span> == <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">EndVnode</span> == <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">new</span><span class="type">EndVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[--<span class="keyword">new</span><span class="type">EndIdx</span>]</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, <span class="keyword">new</span><span class="type">StartVnode</span>)) &#123;</div><div class="line">                patchVnode(oldStartVnode, <span class="keyword">new</span><span class="type">StartVnode</span>)</div><div class="line">                oldStartVnode = oldCh[++oldStartIdx]</div><div class="line">                <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, <span class="keyword">new</span><span class="type">EndVnode</span>)) &#123;</div><div class="line">                patchVnode(oldEndVnode, <span class="keyword">new</span><span class="type">EndVnode</span>)</div><div class="line">                oldEndVnode = oldCh[--oldEndIdx]</div><div class="line">                <span class="keyword">new</span><span class="type">EndVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[--<span class="keyword">new</span><span class="type">EndIdx</span>]</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, <span class="keyword">new</span><span class="type">EndVnode</span>)) &#123;</div><div class="line">                patchVnode(oldStartVnode, <span class="keyword">new</span><span class="type">EndVnode</span>)</div><div class="line">                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</div><div class="line">                oldStartVnode = oldCh[++oldStartIdx]</div><div class="line">                <span class="keyword">new</span><span class="type">EndVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[--<span class="keyword">new</span><span class="type">EndIdx</span>]</div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, <span class="keyword">new</span><span class="type">StartVnode</span>)) &#123;</div><div class="line">                patchVnode(oldEndVnode, <span class="keyword">new</span><span class="type">StartVnode</span>)</div><div class="line">                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</div><div class="line">                oldEndVnode = oldCh[--oldEndIdx]</div><div class="line">                <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</div><div class="line">            &#125;<span class="keyword">else</span> &#123;</div><div class="line">               <span class="comment">// 使用key时的比较</span></div><div class="line">                <span class="keyword">if</span> (oldKeyToIdx === undefined) &#123;</div><div class="line">                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) <span class="comment">// 有key生成index表</span></div><div class="line">                &#125;</div><div class="line">                idxInOld = oldKeyToIdx[<span class="keyword">new</span><span class="type">StartVnode</span>.key]</div><div class="line">                <span class="keyword">if</span> (!idxInOld) &#123;</div><div class="line">                    api.insertBefore(parentElm, createEle(<span class="keyword">new</span><span class="type">StartVnode</span>).el, oldStartVnode.el)</div><div class="line">                    <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    elmToMove = oldCh[idxInOld]</div><div class="line">                    <span class="keyword">if</span> (elmToMove.sel !== <span class="keyword">new</span><span class="type">StartVnode</span>.sel) &#123;</div><div class="line">                        api.insertBefore(parentElm, createEle(<span class="keyword">new</span><span class="type">StartVnode</span>).el, oldStartVnode.el)</div><div class="line">                    &#125;<span class="keyword">else</span> &#123;</div><div class="line">                        patchVnode(elmToMove, <span class="keyword">new</span><span class="type">StartVnode</span>)</div><div class="line">                        oldCh[idxInOld] = <span class="literal">null</span></div><div class="line">                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">new</span><span class="type">StartVnode</span> = <span class="keyword">new</span><span class="type">Ch</span>[++<span class="keyword">new</span><span class="type">StartIdx</span>]</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</div><div class="line">            before = <span class="keyword">new</span><span class="type">Ch</span>[<span class="keyword">new</span><span class="type">EndIdx</span> + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="type">newCh</span>[<span class="keyword">new</span><span class="type">EndIdx</span> + <span class="number">1</span>].el</div><div class="line">            addVnodes(parentElm, before, <span class="keyword">new</span><span class="type">Ch</span>, <span class="keyword">new</span><span class="type">StartIdx</span>, <span class="keyword">new</span><span class="type">EndIdx</span>)</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">StartIdx</span> &gt; <span class="keyword">new</span><span class="type">EndIdx</span>) &#123;</div><div class="line">            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码很密集，为了形象的描述这个过程，可以看看这张图。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff2.png" alt="比较过程"><br>过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。<br><strong>具体的diff分析</strong><br>设置key和不设置key的区别：<br>不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</p>
<p>diff的遍历过程中，只要是对dom进行的操作都调用api.insertBefore，api.insertBefore只是原生insertBefore的简单封装。<br>比较分为两种，一种是有vnode.key的，一种是没有的。但这两种比较对真实dom的操作是一致的。</p>
<p>对于与sameVnode(oldStartVnode, newStartVnode)和sameVnode(oldEndVnode,newEndVnode)为true的情况，不需要对dom进行移动。</p>
<p>总结遍历过程，有3种dom操作：</p>
<p>1、当oldStartVnode，newEndVnode值得比较，说明oldStartVnode.el跑到oldEndVnode.el的后边了。<br>图中假设startIdx遍历到1。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff3.png" alt="1"><br>2、当oldEndVnode，newStartVnode值得比较，说明是“oldEndVnode.el跑到了oldStartVnode.el的前边”。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff4.png" alt="2"><br>3、newCh中的节点oldCh里没有， 将新节点插入到oldStartVnode.el的前边。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff5.png" alt="3"></p>
<p>在结束时，分为两种情况：<br>1、oldStartIdx &gt; oldEndIdx，可以认为oldCh先遍历完。当然也有可能newCh此时也正好完成了遍历，统一都归为此类。此时newStartIdx和newEndIdx之间的vnode是新增的，调用addVnodes，把他们全部插进before的后边，before很多时候是为null的。addVnodes调用的是insertBefore操作dom节点，我们看看insertBefore的文档：parentElement.insertBefore(newElement, referenceElement)<br>如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。所以before为null，newElement将被插入到子节点的末尾。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff6.png" alt="1"><br>2、newStartIdx &gt; newEndIdx，可以认为newCh先遍历完。此时oldStartIdx和oldEndIdx之间的vnode在新的子节点里已经不存在了，调用removeVnodes将它们从dom里删除。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff7.png" alt="2"><br>下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出。<br>1、a,b,c,d,e假设是4个不同的元素，我们没有设置key时，b没有复用，而是直接创建新的，删除旧的。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff8.png" alt="1"><br>2、当我们给4个元素加上唯一key时，b得到了的复用。<br><img src="https://raw.githubusercontent.com/aooy/blog/master/images/issues-2/diff9.png" alt="2"><br>这个例子如果我们使用手工优化，只需要3步就可以达到。<br><strong>总结：</strong><br>1、尽量不要跨层级的修改dom<br>2、设置key可以最大化的利用节点<br>3、不要盲目相信diff的效率，在必要时可以手工优化</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://laihuamin.github.io/2017/08/02/虚拟dom/" data-id="cj5wi6a0y000krkql3y4i0gsn" class="article-share-link">Aktie</a><div class="tags"></div><div class="post-nav"><a href="/2017/08/03/webpack原理/" class="pre">webpack原理</a><a href="/2017/08/02/vue-router深入学习/" class="next">vue-router深入学习</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://laihuamin.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 其他</i></div><ul></ul><a href="http://www.jianshu.com/u/5be4d0169f64" title="简书" target="_blank">简书</a><ul></ul><a href="https://github.com/laihuamin" title="github" target="_blank">github</a></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/03/webpack原理/">webpack原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/02/虚拟dom/">虚拟dom</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/02/vue-router深入学习/">vue-router深入学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/vuex深入学习/">vuex深入学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/vue的面试总结/">vue面试</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/31/Vue源码之globalApi/">Vue源码之globalApi(index.js)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/29/关于TypeScript/">TypeScript学习笔记（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/29/vue源码-shared/">Vue源码——shared</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/28/vue目录结构分析/">vue源码目录结构分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/27/ES6的新特性（上）/">ES的新特性（上）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 作品集</i></div><ul></ul><a href="http://119.23.222.225:8081/" title="简历" target="_blank">简历</a><ul></ul><a href="http://119.23.222.225:8082/#/goods" title="饿了么作品" target="_blank">饿了么作品</a><ul></ul><a href="http://119.23.222.225:8083/#/recommend" title="音乐App" target="_blank">音乐App</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">蜗居.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>